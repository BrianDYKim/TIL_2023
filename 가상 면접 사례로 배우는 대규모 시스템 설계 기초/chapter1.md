# 1장. 사용자 수에 따른 규모 확장성

## 어떤 데이터베이스를 사용해야 하는가?

전통적으로 데이터베이스는 관계형 데이터베이스와 비관계형 데이터베이스로 나눌 수 있다.

비관계형 데이터베이스는 NoSQL 이라고도 불리는데, 대표적으로는 CouchDB, Neo4J, Cassandra, HBase, Amazon DynamoDB가 존재한다.

이러한 NoSQL은 크게 4종류로 나눌수 있는데, 나뉘는 종류는 아래와 같다.
- 키-값 저장소 (Key-Value Store)
- 그래프 저장소 (Graph Store)
- 컬럼 저장소 (Column Store)
- 문서 저장소 (Document Store)

일반적으로 이러한 NoSQL은 **조인 연산을 지원하지 않기 때문에, 비정규화를 통해 테이블을 설계해야한다.**

대부분의 개발자들에게는 RDB가 최선의 정답이 될 수 있지만, 아래의 사례의 경우에는 NoSQL도 고려해볼 수 있음을 인지하자:
1. 아주 낮은 Latency를 보장해야할 경우
2. 다루는 데이터가 스키마 및 관계가 명확하지 않고, 비정형인 경우
3. 데이터를 직렬화 하거나, 혹은 역직렬화할 수 있기만 하면 되는 경우 (단순 데이터 저장)
4. 아주 많은 양의 데이터를 저장할 필요가 있는 경우 (NoSQL은 RDB와는 다르게 분산에 최적화된 벤더 군을 많이 포함하고있기 때문이다)

## 수직적 규모 확장 vs 수평적 규모 확장

**수직적 규모 확장(Vertical Scaling)** 은 단일 서버에 고사양의 자원을 추가하는 행위를 의미한다. 반면에 **수평적 규모 확장(Horizontal Scaling)** 은 더 많은 서버를 추가하여 성능을 개선하는 행위를 의미한다.

서버로 유입되는 트래픽이 적은 경우에는 수직적 규모 확장이 유리할 수 있지만, 수직적 확장은 아래의 명확한 단점을 가지고있다.

- 단일 인스턴스에 CPU 및 RAM을 추가하는데는 한계가 존재한다. Power Wall 현상에 의해 고사양에서 리소스를 추가할 수록 비용은 기하급수적으로 증가하는 현상을 보인다.
- 수직적 규모 확장은 장애에 대한 **자동 복구** 방안이나 **다중화** 방안을 제시하지는 않는다. 즉, 싱글 인스턴스가 뻗게되면 전체 웹 비지니스가 중단되는 현상이 발생한다.

## 로드밸런서 (LoadBalancer)

로드밸런서는 DNS를 통해서 들어온 요청을 WAS 등에 고르게 분산하는 장치를 의미한다. 일반적으로 WAS는 사설 서브넷 (private subnet)에 위치시키고 로드밸런서 인스턴스는 공용 서브넷 (public subnet)에 위치시키는 방식으로 보안을 강화하면서 부하를 분산하는 정책을 채택한다.

## 데이터베이스 다중화

보통은 서버 사이에 Master-Replication 관계를 설정하여 데이터 원본은 master에, 사본을 replication에 저장하는 방식으로 동작한다.

이 중에서 쓰기 연산은 마스터에서 지원하고, 읽기 연산은 replication에서 지원하며, 전체 데이터베이스 시스템은 master-slave 간의 일관성 지원을 위해서 **최종적 일관성(Eventually Consistency)** 를 지원한다. (데이터베이스 토폴로지에 따라서 방법은 다양할수도 있다)

대부분은 데이터베이스는 읽기 연산의 비중이 쓰기 연산의 비중에 비해서 압도적으로 높기 때문에 Replication instance의 개수가 Master instance의 개수보다 훨씬 많도록 설계한다.

- 더 나은 성능: Replication의 개수가 많을 수록 병렬로 처리할 수 있는 쿼리의 개수가 증가하기 때문에 읽기 성능이 향상된다.
- 안정성: 자연 재해등의 이유로 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존된다.
- 가용성: 데이터를 여러 지역에 복제해 둠으로써, 하나의 데이터베이스 서버에 장애가 발생하더라고 다른 서버에 있는 데이터를 가져와 계속 서비스를 지원해줄 수 있다.

만일 데이터베이스 인스턴스 하나에 장애가 일어난 상황을 가정해보자. 그런 경우에는 아래의 일들이 발생한다.

- **Replication이 1대밖에 없는 경우** 에는 Replication이 장애를 일으켰을 때 Master가 읽기 및 쓰기 트래픽을 감당할 것이다. 그리고 새로운 Replication이 클러스터에 참여하여 장애가 복구될 것이다.
- **Master가 다운된 경우, 그리고 Replication이 한 대만 존재하는 경우** 클러스터 내부에서의 다수결 합의과정 없이 Replication이 Master로 승격될 것이다. 하지만, Master에 쌓인 쓰기 연산이 Replication에 전파되지 못한 경우 (즉, 일관성이 지켜지지 않은 순간에 장애가 일어난 것이라면) Replication이 가진 데이터는 최신의 상태가 아니기 때문에 별도의 장애 복구 과정 시나리오가 필요하다. 이를 해결하기 위해 **다중 마스터 정책(Multi Master Policy) 혹은 원형 다중화 (Circular Replication)** 방식을 도입하는 경우도 있다.

## 캐시

캐시를 사용 시에는 아 사항들을 고려하면 좋다.

- **데이터의 갱신이 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려할만하다**
- 캐시 서버는 보통 휘발성 데이터라는 특징이 존재하기 때문에, 중요한 데이터는 영속성 저장소(persistence store)에 저장하는게 좋다
- **일관성(consistency)는 항상 유지되어야한다.** 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 이 일관성은 깨질 수 있다.
- **캐시 서버는 일반적으로 오버 프로비져닝(over provisioning) 하는게 좋다.** 갑자기 캐시서버에 저장할 데이터가 급증하는 경우 캐시 서버의 장애를 대처할 수 있다.
- **캐시 데이터 방출 정책은 중요하다.** 일반적인 캐시 서버는 **LRU(Least Recently Used, 마지막으로 사용된 시점이 가장 오래된 데이터를 내보내는) 정책** 을 사용한다.

## 무상태 웹 계층

웹 계층을 수평적으로 확장을 하기 위해선 첫번째로 고려해볼 것은, **상태정보(사용자 세션 등등)** 을 웹계층으로부터 분리해야한다.

상태 정보 의존적인 아키텍처 상에서는, 만일 A라는 사용자가 있고, A라는 사용자 정보가 서버 1에 존재한다고 가정한다면, 로드밸런서를 통해 서버 2에 특정 요청을 수행한다면 인증에 실패할 수도 있다.

로드밸런서는 이를 대비하기 위해서 **Sticky Session** 이라는 기능이 있지만, 결국에는 서버가 지는 부담을 로드밸런서가 짊어지고 가는 구조이기 때문에 그렇게 바람직한 해결 방안은 아닐수도 있다.

이러한 세션 데이터를 보관하는 것을 웹 서버 혹은 로드밸런서 대신에 NoSQL 데이터베이스를 하나 도입하여 거기에 저장을 수행한다면, 꽤나 훌륭한 방안이 될 수 있을것이다.

## 메시지 큐

메시지큐는 **메시지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트 이다.** 메시지큐를 이용하면 서비스 혹은 서버 간 결합이 느슨해지는 효과를 보이기 때문에, 규모 확장성이 보장되어야 하는 안정적인 애플리케이션을 구성하기가 좋아진다. (특정 애플리케이션이 메시지를 발행하면 다른 애플리케이션은 해당 메시지를 구독하는 방식이기 때문에 서버 간에 의존도가 약해진다)

## 데이터베이스의 수평적 확장

샤딩은 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술을 일컫는다. 즉, 모든 샤드는 같은 스키마를 사용하지만, 샤드에 보관되는 데이터 사이에는 중복키가 존재하지 않아야한다. **(이를 지원하기 위해서 RDB는 auto_increment 옵션을 비추천한다)**

샤딩을 도입하면 시스템이 복잡해지고, 풀어야할 새로운 문제도 발생하는데, 아래와 같다.

- 데이터의 재 샤딩: 샤드 간 데이터 분포가 균등하지 못해서 어떤 샤드에 할당된 공간 소모가 불균등한 경우 특정 샤드의 공간 소모가 다른 샤드에 비해서 빨라지는 현상이 존재한다.
- 유명인사 문제: Hotspot key 문제라고도 부르는데, 특정 파티션키에 대응하는 데이터의 조회가 지나치게 많은 경우 특정 샤드에 읽기 연산이 많이 들어가는 문제가 발생한다. 이는 샤드 간 처리하는 트래픽의 불균등을 유발하므로 성능 저하가 발생할 우려가 존재한다.
- 조인과 비정규화: 샤딩을 도입하면 조인 비용이 엄청나게 늘어나기 때문에 비정규화를 추천한다. (조인을 위해서 모든 샤드에 있는 데이터를 조회해서 조립해야하기 때문에 특정 샤드의 데이터 조회가 느린 경우 해당 샤드가 데이터를 모두 제공할 때 까지 대기해야하는 상황도 벌어질 수 있다)